#redis 分布式锁实现机制

一、什么是分布式锁？

分布式锁是控制分布式系统之间同步访问共享资源的一种方式。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要互斥来防止彼此干扰来保证一致性，在这种情况下，便需要使用到分布式锁。

实现分布式锁有很多实现方式和工具，如Zookeeper、Redis等。


二、为什么需要分布式锁？

在我们业务中，有些数据操作是不允许同时出现多次请求的。如添加一条订单，或者发起一笔支付，如果出现double-click事件，那么会出现脏数据，甚至重复支付的风险。我们必须要禁止对同一个订单进行多次下单和支付。那这个时候就需要对这种业务进行加锁。

同时，因为我们的应用很可能不只部署在一台机器上，那么我们就不能锁定一个单机资源，而是要锁住一个所有服务器都能访问到的资源，形成只能由单机持有资源的情况。单机A使用资源完成，需要释放资源，此时B才能继续申请试用资源。


三、怎样实现redis分布式锁？

1.单机Redis实现分布式锁

    1.1设置锁时，使用set命令。因为包含了setnx,expire的功能，起到原子操作效果，给key设置随机值，并且只有key不存在才设置成功返回true，并且设置key的过期时间。（最好用毫秒）

    从2.6.12版本开始，redis为SET命令增加了一系列选项(set [key] NX/XX EX/PX [expiration]):

    EX seconds – 设置键key的过期时间，单位时秒

    PX milliseconds – 设置键key的过期时间，单位时毫秒

    NX – 只有键key不存在的时候才会设置key的值

    XX – 只有键key存在的时候才会设置key的值


    SET key_name my_random_value NX PX 30000  
  
    # NX 表示if not exist 就设置并返回True，否则不设置并返回False 
    
    # PX 表示过期时间用毫秒级， 30000 表示这些毫秒时间后此key过期

    1.2在获取锁后，并完成相关业务操作，需要删除自己设置的锁（必须是只能删除自己设置的，不能删除别人设置的锁）。

        删除原因：保证服务器资源的高利用效率，不用等到锁自动过期才删除；

        删除方法：最好使用Lua脚本删除（redis保证执行此脚本时不执行其他操作，保证操作的原子性），


    代码如下；逻辑是 先获取key，如果存在并且值是自己设置的就删除此key;否则就跳过；

    if redis.call("get",KEYS[1]) == ARGV[1] then

        return redis.call("del",KEYS[1])

    else

        return 0

    end

    1.3解决死锁

    如果一个持有锁的客户端失败或崩溃了不能释放锁，该怎么解决？

    答：给锁设置一个过期时间，可以通过两种方法实现：通过命令 “setnx 键名 过期时间 “；或者通过设置锁的expire时间，让Redis去删除锁。

    1、第一种实现方式： 

    使用 setnx key “当前系统时间+锁持有的时间”和getset key “当前系统时间+锁持有的时间”组合的命令就可以实现。 

    具体做法如下：

    客户端2发送SETNX lock.test 想要获得锁，由于之前的客户端1还持有锁，所以Redis返回一个0  

    客户端2发送GET lock.test 以检查锁是否超时了，如果没超时，则等待或重试。  

    反之，如果已超时，客户端2通过下面的操作来尝试获得锁：  

    GETSET lock.test 过期的时间 

    通过GETSET，客户端2拿到的时间戳如果仍然是超时的，那就说明，客户端2如愿以偿拿到锁了。
      
    如果在客户端2之前，有个客户端3比客户端2快一步执行了上面的操作，那么客户端2拿到的时间戳是个未超时的值，这时，说明客户端2没有如期获得锁，需要再次等待或重试。 

    尽管客户端2没拿到锁，但它改写了客户端3设置的锁的超时值，不过这一点非常微小的误差带来的影响可以忽略不计。 

2、第二种实现方式： 

    通过Redis中expire()给锁设定最大持有时间，如果超过，则Redis来帮我们释放锁。

    1.客户端1使用setnx获得了锁，并且使用expire设定一个过期时间，假定是10ms

    2.过了4ms后，客户端1不幸运的宕机了，此时客户端2想要通过setnx尝试获得锁，但是锁还没有过期，任然被客户端1所持有。

    3.到了11ms时，锁过期了，Redis帮我们删除了锁，此时客户端2想要通过setnx尝试获得锁，此时就能成功获得锁。

    在实际过程中，我们可以设定一个时间T，用来表示客户端在初次尝试获得锁失败以后，在多次尝试获得锁所花的时间。如果次时间为0，表示除此尝试获得锁失败以后就不会再去尝试获得锁了。

    2.Redis集群实现分布式锁

    上面的讨论中我们有一个非常重要的假设：Redis是单点的。如果Redis是集群模式，我们考虑如下场景:

    客户端1从Master获取了锁。

    Master宕机了，存储锁的key还没有来得及同步到Slave上。

    Slave升级为Master。

    客户端2从新的Master获取到了对应同一个资源的锁。

    客户端1和客户端2同时持有了同一个资源的锁，锁不再具有安全性。

    就此问题，RedLock算法来解决这种问题。

    2.1 RedLock获取锁

    1.获取当前时间。
    
    2.按顺序依次向N个Redis节点执行获取锁的操作。这个获取操作跟前面基于单Redis节点的获取锁的过程相同，包含随机字符串my_random_value，也包含过期时间(比如PX 30000，即锁的有效时间)。为了保证在某个Redis节点不可用的时候算法能够继续运行，这个获取锁的操作还有一个超时时间(time out)，它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个Redis节点获取锁失败以后，应该立即尝试下一个Redis节点。

    3.计算整个获取锁的过程总共消耗了多长时间，计算方法是用当前时间减去第1步记录的时间。如果客户端从大多数Redis节点（>= N/2+1）成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间(lock validity time)，那么这时客户端才认为最终获取锁成功；否则，认为最终获取锁失败。

    4.如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它等于最初的锁的有效时间减去第3步计算出来的获取锁消耗的时间。

    5.如果最终获取锁失败了（可能由于获取到锁的Redis节点个数少于N/2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应该立即向所有Redis节点发起释放锁的操作（即前面介绍的单机Redis Lua脚本释放锁的方法）。

    2.2 RedLock释放锁

    客户端向所有Redis节点发起释放锁的操作，不管这些节点当时在获取锁的时候成功与否。

    2.3 关于RedLock的问题讨论

    如果有节点发生崩溃重启

    假设一共有5个Redis节点：A, B, C, D, E。设想发生了如下的事件序列：

    客户端1成功锁住了A, B, C，获取锁成功（但D和E没有锁住）。

    节点C崩溃重启了，但客户端1在C上加的锁没有持久化下来，丢失了。

    节点C重启后，客户端2锁住了C, D, E，获取锁成功。

    客户端1和客户端2同时获得了锁。

    为了应对这一问题，antirez又提出了延迟重启(delayed restarts)的概念。也就是说，一个节点崩溃后，先不立即重启它，而是等待一段时间再重启，这段时间应该大于锁的有效时间(lock validity time)。这样的话，这个节点在重启前所参与的锁都会过期，它在重启后就不会对现有的锁造成影响。

    如果客户端长期阻塞导致锁过期

    客户端1在获得锁之后发生了很长时间的GC pause，在此期间，它获得的锁过期了，而客户端2获得了锁。当客户端1从GC pause中恢复过来的时候，它不知道自己持有的锁已经过期了，它依然向共享资源发起了写数据请求，而这时锁实际上被客户端2持有，因此两个客户端的写请求就有可能冲突（锁的互斥作用失效了）。

    如何解决这个问题呢?引入了fencing token的概念：


    客户端1先获取到的锁，因此有一个较小的fencing token，等于33，而客户端2后获取到的锁，有一个较大的fencing token，等于34。客户端1从GC pause中恢复过来之后，依然是向存储服务发送访问请求，但是带了fencing token = 33。存储服务发现它之前已经处理过34的请求，所以会拒绝掉这次33的请求。这样就避免了冲突。

    但是其实这已经超出了Redis实现分布式锁的范围，单纯用Redis没有命令来实现生成Token。



时钟跳跃问题

假设有5个Redis节点A, B, C, D, E。

客户端1从Redis节点A, B, C成功获取了锁（多数节点）。由于网络问题，与D和E通信失败。

节点C上的时钟发生了向前跳跃，导致它上面维护的锁快速过期。

客户端2从Redis节点C, D, E成功获取了同一个资源的锁（多数节点）。

客户端1和客户端2现在都认为自己持有了锁。

这个问题用Redis实现分布式锁暂时无解。而生产环境这种情况是存在的。

四、结论

Redis并不能实现严格意义上的分布式锁。但是这并不意味着上面讨论的方案一无是处。如果你的应用场景为了效率(efficiency)，协调各个客户端避免做重复的工作，即使锁失效了，只是可能把某些操作多做一遍而已，不会产生其它的不良后果。但是如果你的应用场景是为了正确性(correctness)，那么用Redis实现分布式锁并不合适，会存在各种各样的问题，且解决起来就很复杂，为了正确性，需要使用zab、raft共识算法，或者使用带有事务的数据库来实现严格意义上的分布式锁。



