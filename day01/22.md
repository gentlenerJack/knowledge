#你了解那些数据库优化方案? 
	
这个优化法则归纳为5个层次：  

1、  减少数据访问（减少磁盘访问）	性能提升效果：1~1000  优化成本：		低

	①创建使用正确的索引（数据库索引的原理非常简单，但在复杂的表中真正能正确			使用索引的人很少，即使是专业的DBA也不一定能完全做到最优。）
	②只通过索引访问数据（有些时候，我们只是访问表中的几个字段，并且字段内容			较少，我们可以为这几个字段单独建立一个组合索引，这样就可以直接只通过			访问索引就能得到数据，一般索引占用的磁盘空间比表小很多，所以这种方式			可以大大减少磁盘IO开销。）
	③优化sql执行计划。（优秀的关系型数据库除了需要支持复杂的SQL语法及更多
		  函数外，还需要有一套优秀的算法库来提高SQL性能，目前ORACLE有SQL执行		  计划的算法约300种，而且一直在增加，所以SQL执行计划是一个非常复杂的		  课题，一个普通DBA（下方有扩展）能掌握50种就很不错了，就算是资深DBA			也不可能把每个执行计划的算法描述清楚。虽然有这么多种算法，但并不表示			我们无法优化执行计划，因为我们常用的SQL执行计划算法也就十几个，如果			一个程序员能把这十几个算法搞清楚，那就掌握了80%的SQL执行计划调优知			识。）

2、  返回更少数据（减少网络传输或磁盘访问）      性能提升效果：1~100  		优化成本：低
		①分页显示数据
		②只返回需要的字段

3、  减少交互次数（减少网络传输）	性能提升效果：1~20  优化成本：		低

		①batch DML：（数据库访问框架一般都提供了批量提交的接口，jdbc支持batch的		提交处理方法，当你一 次性要往一个表中插入1000万条数据时，如果采用普通的		executeUpdate处理，	那么和服务器交互次数为1000万次，按每秒钟可以向数据		库服务器提交10000次估算，要完成所有工作需要1000秒。如果采用批量提交模		式，1000条提交一次，那么和服务器交互次数为1万次，交互次数大大减少。采		用batch操作一般不会减少很多数据库服务器的物理IO，但是会大大减少客户端与		服务端的交互次数，从而减少了多次发起的网络延时开销，同时也会降低数据库的		CPU开销。）
		②In List：比如：select * from mytable where id in(:id1,id2,...,idn);
		  通过这样处理可以大大减少SQL请求的数量，从而提高性能。
		   评估在IN里面一次放多少个值还需要考虑应用服务器本地内存的开销，
		  有并发访问时要计算本地数据使用周期内的并发上限，否则可能会导致内存溢			出。
		     综合考虑，一般IN里面的值个数超过20个以后性能基本没什么太大变化，			也特别说明不要超过100，超过后可能会引起执行计划的不稳定性及增加数据			库CPU及内存成本，这个需要专业DBA评估。
			③设置Fetch Size：
		    当我们采用select从数据库查询数据时，数据默认并不是一条一条返回给客户			端的，也不是一次全部返回客户端的，而是根据客户端fetch_size参数处理，			每次只返回fetch_size条记录，当客户端游标遍历到尾部时
		  再从服务端取数据，直到最后全部传送完成。所以如果我们要从服务端一次取大			量数据时，可以加大fetch_size，这样可以减少结果数据传输的交互次数及服			务器数据准备时间，提高性能。
		    fetchsize并不会存在一个最优的固定值，因为整体性能与记录集大小及硬件平			台有关。
	          根据测试结果建议当一次性要取大量数据时这个值设置为100左右，不要小			于40。注意，fetchsize不能设置太大，如果一次取出的数据大于JVM的内存			会导致内存溢出，所以建议不要超过1000，太大了也没什么性能提高，反而			可能会增加内存溢出的危险。
		④使用存储过程
		   大型数据库一般都支持存储过程，合理的利用存储过程也可以提高系统性能。
		⑤优化业务逻辑


4、  减少服务器CPU开销（减少CPU及内存开销）	性能提升效果：1~5  	优化成本：低

		①使用绑定变量：
		    不使用绑定变量的系统当并发达到8000时会在CPU上产生瓶颈，当使用绑定			变量的系统当并行达到16000时会在磁盘IO上产生瓶颈。所以如果你的系统			CPU有瓶颈时请先检查是否存在大量的硬解析操作。
		     如果我们不采用绑定变量，采用字符串拼接的模式生成SQL,那么每条SQL都			会产生执行计划，这样会导致共享池耗尽，缓存命中率也很低。
		  	一些不使用绑定变量的场景：
		    a、数据仓库应用，这种应用一般并发不高，但是每个SQL执行时间很长，SQL				解析的时间相比SQL执行时间比较小，绑定变量对性能提高不明显。数据				仓库一般都是内部分析应用，所以也不太会发生SQL注入的安全问题。
		    b、数据分布不均匀的特殊逻辑，如产品表，记录有1亿，有一产品状态字段，			上面建有索引，有审核中，审核通过，审核未通过3种状态，其中审核通过			9500万，审核中1万，审核不通过499万。
			   采用绑定变量的话，那么只会有一个执行计划，如果走索引访问，那么对			于审核中查询很快，对审核通过和审核不通过会很慢；如果不走索引，那么对			于审核中与审核通过和审核不通过时间基本一样；
			   对于这种情况应该不使用绑定变量，而直接采用字符拼接的方式生成SQL，				这样可以为每个SQL生成不同的执行计划	
		②合理使用排序
		③减少比较操作
		（1、Like模糊查询：Like模糊查询对于数据库来说不是很擅长，特别是你需要模			糊检查的记录有上万条以上时，
		     性能比较糟糕，这种情况一般可以采用专用Search或者采用全文索引方案来			提高性能。
		 2、不能使用索引定位的大量In List）
		  ④大量复杂运算在客户端处理
		      什么是复杂运算，一般我认为是一秒钟CPU只能做10万次以内的运算。如			含小数的对数及指数运算、三角函数、3DES及BASE64数据加密算法等等。如		  	果有大量这类函数运算，尽量放在客户端处理，一般CPU每秒中也只能处理
		  1万-10万次这样的函数运算，放在数据库内不利于高并发处理。

5、  利用更多资源（增加资源）	性能提升效果：@~10  优化成本：高
	   
		①客户端多进程并行访问
		②数据库并行处理


40、扩展  DBA

   1、什么是 DBA？

         数据库管理员（Database Administrator，简称DBA），是从事管理和维护数据库管		理系统(DBMS)的相关工作人员的统称，属于运维工程师的一个分支，主要负责业		务数据库从设计、测试到部署交付的全生命周期管理。

		DBA的核心目标是保证数据库管理系统的稳定性、安全性、完整性和高性能。

		在国外，也有公司把DBA称作数据库工程师(Database Engineer)，两者的工作内容		基本相同，都是保证数据库服务7*24小时的稳定高效运转，但是需要区分一下DBA		和数据库开发工程师(Database Developer)：

		1) 数据库开发工程师的主要职责是设计和开发数据库管理系统和数据库应用软件		系统，侧重于软件研发；

		2) DBA的主要职责是运维和管理数据库管理系统，侧重于运维管理。


Mysql 行存储 列存储（技术点）
	1.在数据写入上的对比
	  1）行存储的写入是一次完成。如果这种写入建立在操作系统的文件系统上，可以保		证写入过程的成功或者失败，数据的完整性因此可以确定。

	  2）列存储由于需要把一行记录拆分成单列保存，写入次数明显比行存储多（意味着		磁头调度次数多，而磁头调度是需要时间的，一般在1ms~10ms)，再加上磁头需要		在盘片上移动和定位花费的时间，实际时间消耗会更大。所以，行存储在写入上占		有很大的优势。

	  3）还有数据修改,这实际也是一次写入过程。不同的是，数据修改是对磁盘上的记录		做删除标记。行存储是在指定位置写入一次，列存储是将磁盘定位到多个列上分别		写入，这个过程仍是行存储的列数倍。所以，数据修改也是以行存储占优。

	2.在数据读取上的对比
	  1）数据读取时，行存储通常将一行数据完全读出，如果只需要其中几列数据的情况，		就会存在冗余列，出于缩短处理时间的考量，消除冗余列的过程通常是在内存中进		行的。

	  2）列存储每次读取的数据是集合的一段或者全部，不存在冗余性问题。

	  3） 两种存储的数据分布。由于列存储的每一列数据类型是同质的，不存在二义性问		题。比如说某列数据类型为整型(int)，那么它的数据集合一定是整型数据。这种情		况使数据解析变得十分容易。相比之下，行存储则要复杂得多，因为在一行记录中		保存了多种类型的数据，数据解析需要在多种数据类型之间频繁转换，这个操作很		消耗CPU，增加了解析的时间。所以，列存储的解析过程更有利于分析大数据。

	  4）从数据的压缩以及更性能的读取来对比	

3、InnoDB存储引擎有两种文件格式
Antelope:compact与redundant两种行记录格式
Barracuda:compress与dynamic两种行记录格式
查看表的行记录格式：
show table status like '%sys_appinfo%'\G;
查看数据库默认的行记录格式：
show variables like '%row_format%';
文件格式查看方式：
show variables like 'innodb_file%';（'innodb_file）
扩展：
MySQL5.7默认使用Barracuda文件格式与dynamic行记录格式。
compact是目前使用最多的一种，而dynamic时新版本默认的行记录格式。
在生产中，我们应该选择哪种行记录格式？
这要说明行溢出：行溢出简单来讲就是需要存储的数据在当前页面之外，拆分到多个页进行存储。
针对大数据类型text或者blob存储在其字段中的数据，dynamic实际采用的数据都存放在溢出的
页中(off-page)，而数据页只存储前20个字节指针。在compact行格式下，溢出的列只存放768个
前缀字节。dynamic这种行格式模式，针对溢出列所在的新页利用率更高。所以，目前生产环境
中建议尽量使用dynamic这种行格式模式，针对溢出列所在的新页利用率更高。
redundant是最早的行记录格式，相比compact要消耗更多的存储空间，不建议使用。
compressed是压缩格式，是对数据和索引进行压缩。但只是针对物理存储层面上的压缩，而在
内存中是不压缩的。当数据调用到内存中就涉及到转换，会很消耗CPU资源，而且效率很低。
压缩比不高，大概直接进1/2的比例。压缩带来负面影响大，数据库TPS会下降，影响现有的线上业务，
不建议使用。

