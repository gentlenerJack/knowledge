#读写分离的原理?
读写分离的基本实现是:
数据库服务器搭建主从集群，一主一从、一主多从都可以。 数据库主机负责读写操作，从机只负责读操作。 数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据。 业务服务器将写操作发给数据库主机，将读操作发给数据库从机。

注意点:这里用的是“主从集群”，而不是“主备集群”。“从机”的“从”可以理解为“仆从”，仆从 是要帮主人干活的，“从机”是需要提供读数据的功能的;而“备机”一般被认为仅仅提供备份 功能，不提供访问功能。所以使用“主从”还是“主备”，是要看场景的，这两个词并不是完全 等同的。

读写分离简单的说是把对数据库读和写的操作分开对应不同的数据库服务器，这样能有效
地减轻数据库压力，也能减轻 io 压力。主数据库提供写操作，从数据库提供读操作，其
实在很多系统中，主要是读的操作。当主数据库进行写操作时，数据要同步到从的数据
 库，这样才能有效保证数据库完整性。

#什么时候用读写分离?
1、 你的系统写入数据不多但是存在大量的读取数据功能。 

2、读写分离并不取决于你的数据量还是取决于你的并发量，访问用户多才需要类似的 功能。 

3、读写分离其实是个比较低端的处理读取并发量的操作，因为还是有对数据库的访问 操作的，但是读写分离相对于其它处理方式而言的好处在于时效性比较高和对系统要求 比较低。 

4、读写分离在效率上是低于页面静态化和缓存服务的，但是好处是不用改动系统代码， 因为都是连接数据库。 

5、数据量大的情况下使用的技术不是读写分离，是分表和分库，或者使用分布式存储 引擎，读写分离不能解决数据量大的问题。 

6、系统写入操作并发量大不适合使用读写分离，至于需要什么技术看你的具体业务需 求，而且大量写入操作本身就是个难以处理的大数据问题，但是读写分离从一定程度上 减轻写入操作的负担。
             
#如何实现 MySQL 的读写分离?
  其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个
从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上
   去。
#mysql 主从同步的原理很简单
从库生成两个线程，一个 I/O 线程，一个 SQL 线程;i/o 线程去请求主库 的 binlog(二进制日志)，并将得到的 binlog 日志写到 relay log(中继日志) 文件中;主库会生成一个 log dump 线程，用来给从库 i/o 线程传 binlog;
SQL 线程，会读取 relay log 文件中的日志，并解析成具体操作，来实现主从 的操作一致，而最终数据一致。
MySQL 主从复制原理的?
主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志 中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保
 证自己跟主库的数据是一样的。

  这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的， 也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要 的点了，由于从库从主库拷贝日志以及串行执行 SQL 的特点，在高并发场景 下，从库的数据一定会比主库慢一些，是有延时的。所以经常出现，刚写入主 库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。
  而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没
同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。
所以 MySQL 实际上在这一块有两个机制，一个是半同步复制，用来解决
 主库数据丢失问题;一个是并行复制，用来解决主从同步延时问题。
这个所谓半同步复制，也叫 semi-sync 复制，指的就是主库写入 binlog 日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地 的 relay log 之后，接着会返回一个 ack 给主库，主库接收到至少一个从库 的 ack 之后才会认为写操作完成了。

 所谓并行复制，指的是从库开启多个线程，并行读取 relay log 中不同库 的日志，然后并行重放不同库的日志，这是库级别的并行。

#MySQL 主从同步延时问题(精华)
以前线上确实处理过因为主从同步延时问题而导致的线上的 bug，属于小
  型的生产事故。
 是这个么场景。有个同学是这样写代码逻辑的。先插入一条数据，再把它 查出来，然后更新这条数据。在生产环境高峰期，写并发达到了 2000/s，这 个时候，主从复制延时大概是在小几十毫秒。线上会发现，每天总有那么一些 数据，我们期望更新一些重要的数据状态，但在高峰期时候却没更新。用户跟 客服反馈，而客服就会反馈给我们。
我们通过 MySQL 命令:
show status
查看 Seconds_Behind_Master，可以看到从库复制主库的数据落后了几 ms。

 一般来说，如果主从延迟较为严重，有以下解决方案:

 • 分库，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此
  时主从延迟可以忽略不计。

• 打开 MySQL 支持的并行复制，多个库并行复制。如果说某个库的写入并 发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义。

• 重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。

 • 如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执 行一些操作，对这个查询设置直连主库。不推荐这种方法，你要是这么 搞，读写分离的意义就丧失了。
#复制延迟
以 MySQL 为例，主从复制延迟可能达到 1 秒，如果有大量数据同步，延迟 1 分钟也是有 可能的。主从复制延迟会带来一个问题:如果业务服务器将数据写入到数据库主服务器后立 刻(1 秒内)进行读取，此时读操作访问的是从机，主机还没有将数据复制过来，到从机读 取数据是读不到最新数据的，业务上就可能出现问题。例如，用户刚注册完后立刻登录，业 务服务器会提示他“你还没有注册”，而用户明明刚才已经注册成功了。
解决主从复制延迟有几种常见的方法:

1. 写操作后的读操作指定发给数据库主服务器

例如，注册账号完成后，登录时读取账号的读操作也发给数据库主服务器。这种方式和业务 强绑定，对业务的侵入和影响较大，如果哪个新来的程序员不知道这样写代码，就会导致一 个 bug。

2. 读从机失败后再读一次主机

这就是通常所说的“二次读取”，二次读取和业务无绑定，只需要对底层数据库访问的 API 进 行封装即可，实现代价较小，不足之处在于如果有很多二次读取，将大大增加主机的读操作 压力。例如，黑客暴力破解账号，会导致大量的二次读取操作，主机可能顶不住读操作的压 力从而崩溃。

3. 关键业务读写操作全部指向主机，非关键业务采用读写分离

例如，对于一个用户管理系统来说，注册 + 登录的业务读写操作全部访问主机，用户的介 绍、爱好、等级等业务，可以采用读写分离，因为即使用户改了自己的自我介绍，在查询时 却看到了自我介绍还是旧的，业务影响与不能登录相比就小很多，还可以忍受。

#Mysql 主从配置，实现读写分离
 具体实现:
1、在主从服务器上都装上 MySQL 数据库，windows 系统鄙人安装的是 mysql_5.5.25.msi
版本，Ubuntu 安装的是 mysql-5.6.22-linux-glibc2.5-i686.tar
windows 安装 mysql 就不谈了，一般地球人都应该会。鄙人稍微说一下 Ubuntu 的 MySQL 安装，我建议不要在线下载安装，还是离线安装的好。大家可以参
考 http://www.linuxidc.com/Linux/2013-01/78716.htm 这位不知道大哥还是姐妹，写 的挺好按照这个就能装上。在安装的时候可能会出现几种现象，大家可以参考解决一下:

(1)如果您不是使用 root 用户登录，建议 su - root 切换到 Root 用户安装，那就不用老是 sudo 了。

(2)存放解压的 mysql 文件夹，文件夹名字最好改成 mysql

(3)在./support-files/mysql.server start 启动 MySQL 的时候，可能会出现一个警告， 中文意思是启动服务运行读文件时，忽略了 my.cnf 文件，那是因为 my.cnf 的文件权限有问 题，mysql 会认为该文件有危险不会执行。但是 mysql 还会启动成功，但如果下面配置从服 务器参数修改 my.cnf 文件的时候，你会发现文件改过了，但是重启服务时，修改过后的配置 没有执行，而且您 list 一下 mysql 的文件夹下会发现很多.my.cnf.swp 等中间文件。这都是 因为 MySQL 启动时没有读取 my.cnf 的原因。这时只要将 my.cnf 的文件权限改成 my_new.cnf 的权限一样就 Ok，命令:chmod 644 my.cnf 就 Ok

(4)Ubuntu 中修改文档内容没有 Vim，最好把 Vim 装上，apt-get install vim,不然估计 会抓狂。
这时候我相信 MySQL 应该安装上去了。 

2、配置 Master 主服务器

(1)在 Master MySQL 上创建一个用户‘repl’，并允许其他 Slave 服务器可以通过远程访问 Master，通过该用户读取二进制日志，实现数据同步。
   1 mysql>create user repl; //创建新用户
2 //repl 用户必须具有 REPLICATION SLAVE 权限，除此之外没有必要添加不必 要的权限，密码为 mysql。说明一下 192.168.0.%，这个配置是指明 repl 用户 所在服务器，这里%是通配符，表示 192.168.0.0-192.168.0.255 的 Server 都 可以以 repl 用户登陆主服务器。当然你也可以指定固定 Ip。
3 mysql> GRANT REPLICATION SLAVE ON *.* TO 'repl'@'192.168.0.%' IDENTIFIED BY 'mysql';

(2)找到 MySQL 安装文件夹修改 my.Ini 文件。mysql 中有好几种日志方式，这不是今天 的重点。我们只要启动二进制日志 log-bin 就 ok。
在[mysqld]下面增加下面几行代码
 1 server-id=1 //给数据库服务的唯一标识，一般为大家设置服务器 Ip 的末 尾号
2 log-bin=master-bin
3 log-bin-index=master-bin.index

(3)查看日志
mysql> SHOW MASTER STATUS;
 +-------------------+----------+--------------+------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | +-------------------+----------+--------------+------------------+ | master-bin.000001 | 1285 | | | +-------------------+----------+--------------+------------------+ 1 row in set (0.00 sec)
重启 MySQL 服务

3、配置 Slave 从服务器(windows)

(1)找到 MySQL 安装文件夹修改 my.ini 文件，在[mysqld]下面增加下面几行代码
  1 [mysqld]
2 server-id=2
3 relay-log-index=slave-relay-bin.index
4 relay-log=slave-relay-bin
 重启 MySQL 服务 
 
 (2)连接 Master

change master to master_host='192.168.0.104', //Master 服务器 Ip master_port=3306,
master_user='repl',
master_password='mysql',
 master_log_file='master-bin.000001',//Master 服务器产生的日志 master_log_pos=0;

(3)启动 Slave

start slave;

4、Slave 从服务器(Ubuntu)

(1)找到 MySQL 安装文件夹修改 my.cnf 文件,vim my.cnf

(2)./support-files/myql.serverrestart重启MySQL服务 , ./bin/mysql进入
MySQL 命令窗口 

(3)连接 Master

change master to master_host='192.168.0.104', //Master 服务器 Ip master_port=3306,
master_user='repl',
master_password='mysql', master_log_file='master-bin.000001',//Master 服务器产生的日志 master_log_pos=0;

(4)启动 Slave start slave;

Mysql 主从复制原理 参考博客:https://www.cnblogs.com/kevingrace/p/6256603.html

Mysql 主从同步
1、mysql 主从同步(复制)概念

1. 将 Mysql 某一台主机数据复制到其它主机(slaves)上，并重新执行一遍来实现的。 

2. 复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。

3. 主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环。

4. 当一个从服务器连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成
功更新的位置。

5. 从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新。
binlog:是二进制日志文件，用于记录 mysql 的数据更新或者潜在更新(比如 DELETE 语句执行删除而实际并没有符合条件的数据)


2、Mysql 支持哪些复制


1. 基于语句的复制: 在主服务器执行 SQL 语句，在从服务器执行同样语句。 注:MySQL 默认采用基于语句的复制，效率较高。一旦发现没法精确复制时, 会自动选
基于行的复制。

2. 基于行的复制: 把改变的内容复制过去，而不是把命令在从服务器上执行一遍. 从
mysql5.0 开始支持

3. 混合类型的复制: 默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，
就会采用基于行的复制。

3、Mysql 主从复制原理

1. master 服务器将数据的改变都记录到二进制 binlog 日志中，只要 master 上的数据 发生改变，则将其改变写入二进制日志;

2. salve 服务器会在一定时间间隔内对 master 二进制日志进行探测其是否发生改变，如 果发生改变，则开始一个 I/O Thread 请求 master 二进制事件

3. 同时主节点为每个 I/O 线程启动一个 dump 线程，用于向其发送二进制事件，并保存
 至从节点本地的中继日志中

4. 从节点将启动 SQL 线程从中继日志中读取二进制日志，在本地重放，使得其数据和主
节点的保持一致

5. 最后 I/O Thread 和 SQL Thread 将进入睡眠状态，等待下一次被唤醒。

需要理解:
1)从库会生成两个线程,一个 I/O 线程,一个 SQL 线程;

2)I/O 线程会去请求主库的 binlog,并将得到的 binlog 写到本地的 relay-log(中继日志)
文件中;

3)主库会生成一个 log dump 线程,用来给从库 I/O 线程传 binlog; 4)SQL 线程,会读取 relay log 文件中的日志,并解析成 sql 语句逐一执行;

4、Mysql 复制流程图

1. master 将操作语句记录到 binlog 日志中

2. salve 服务器会在一定时间间隔内对 master 二进制日志进行探测其是否发生改变，如 果发生改变

3. salave 开启两个线程:IO 线程和 SQL 线程

1)IO 线程:负责读取 master 的 binlog 内容到中继日志 relay log 里;

2)SQL 线程:负责从 relay log 日志里读出 binlog 内容，并更新到 slave 的数据库里

(保证数据一致)
 #Mysql 同步延迟问题
1、造成 mysql 同步延迟常见原因

1)网络:如主机或者从机的带宽打满、主从之间网络延迟很大，导致主上的 binlog 没有 全量传输到从机，造成延迟。

2)机器性能:从机使用了烂机器?比如主机使用 SSD 而从机还是使用的 SATA。

3)从机高负载:有很多业务会在从机上做统计，把从机服务器搞成高负载，从而造成从 机延迟很大的情况

4)大事务:比如在 RBR 模式下，执行带有大量的 delete 操作，这种通过查看 processlist 相关信息以及使用 mysqlbinlog 查看 binlog 中的 SQL 就能快速进行确认

5)锁: 锁冲突问题也可能导致从机的 SQL 线程执行慢，比如从机上有一些 select .... for update 的 SQL，或者使用了 MyISAM 引擎等。

2、硬件方面(优化)

1.采用好服务器，比如 4u 比 2u 性能明显好，2u 比 1u 性能明显好。

2.存储用 ssd 或者盘阵或者 san，提升随机写的性能。 

3.主从间保证处在同一个交换机下面，并且是万兆环境。 总结:硬件强劲，延迟自然会变小。一句话，缩小延迟的解决方案就是花钱和花时间。

3、mysql 主从同步加速

1)sync_binlog 在 slave 端设置为 0
当事务提交后，Mysql 仅仅是将 binlog_cache 中的数据写入 Binlog 文件，但不执行
fsync 之类的磁盘 同步指令通知文件系统将缓存刷新到磁盘
而让 Filesystem 自行决定什么时候来做同步，这个是性能最好的。


2)slave 端 innodb_flush_log_at_trx_commit = 2
每次事务提交时 MySQL 都会把 log buffer 的数据写入 log file，但是 flush(刷到磁盘)操 作并不会同时进行。

该模式下，MySQL 会每秒执行一次 flush(刷到磁盘)操作。 

3)–logs-slave-updates 从服务器从主服务器接收到的更新不记入它的二进制日志。 

4)直接禁用 slave 端的 binlog