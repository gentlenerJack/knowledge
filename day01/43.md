#数据库锁

1. Mysql数据库有三种锁的级别

行级锁:行级锁是Mysql中锁定粒度最细的一种锁，能大大减少数据库操作的冲突，由于其粒度小，加	锁的开销最大。行级锁分为共享锁和排他锁

表级锁:每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；

页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

2. 什么是数据库锁

锁是网络数据库中的一个非常重要的概念，当多个用户同时对数据库并发操作时，会带来数据不一致的问题，所以，锁主要用于多用户环境下保证数据库完整性和一致性。

3. 数据库都有哪些锁及详解

从数据库系统角度分为三种：排他锁、共享锁、更新锁。 

从程序员角度分为两种：一种是悲观锁，一种乐观锁。

*共享锁:*

什么是共享锁：简单来说就是该锁锁定的资源只能进行读取，不能进行增删改操作，直到该锁释放。

example 1：

请求1：select * from  tabletest

请求2：update tabletast set ....

数据库执行请求1的sql语句，是select语句，数据库会给该表加上共享锁，查询的数据保持一致，这时如果请求1还没释放共享锁，数据库执行请求2的sql语句，是update语句，数据库会给该表加上排它锁，但是同一资源共享锁和排他锁是不能共存的，所以请求2 只能等请求1执行完释放共享锁，这时请求2的update才能进行。

example 2:

请求1：select * from  tabletest

请求2：select * from  tabletest

数据库执行请求1的sql语句，是select语句，数据库会给该表加上共享锁，数据库执行请求2的sql语句，数据库也会给该表加上共享锁，这时请求1 不会阻塞请求2，因为同一个资源共享锁是可以叠加的，共享锁与共享锁兼容。

example 3:

请求1：select * from  tabletest

请求2：select * from  tabletest

请求3：update tabletast set ....

数据库执行请求1的sql语句，是select语句，数据库会给该表加上共享锁，数据库执行请求2的sql语句，数据库也会给该表加上共享锁，请求3的update语句，只有等请求1，请求2的共享锁都释放掉，请求3的sql语句才会执行。

结论

1.数据库同一条资源是不能同时存在两条锁的

2.共享锁是可以叠加的

3.共享锁只支持读取数据

加锁: select name from goods lock in share mode;

在查询语句后面加  lock in share mode 就是共享锁

*排它锁：*
排他锁又称为写锁，简称X锁，排它锁不能以其他锁并存，如一个事务获取了一条数据的排它	锁，其他事务就不能获取该条数据的的排它锁，但是排它锁可以对数据进行修改和读取

加锁语法： select name from goods for update;

在查询或修改语句后加 for update 就是加了排它锁
*更新锁：*
用来预定要对此页施加排它锁，它允许其他事务读，但不允许再施加更新锁或排它锁；当被读取的页	将要被更新时，则升级为排它锁；排它锁一直到事务结束时才能被释放。 
*悲观锁：*
悲观锁的特点是一锁二查三更新，先获取锁 ，在进行业务操作，等业务操作完之后才会释放锁

加锁语法： select name from goods for update;

在查询或修改语句后加 for update 就是加了排它锁
*乐观锁：*
乐观锁的特点是先进行业务操作，进行完业务操作要实际更新数据去拿一下锁就好了
乐观锁的实现原理是
在数据库表中创建一个字段记录数据版本，什么是数据版本呢，就是数据标识，具体实现过程就是当用户要修改数据的时候将数据和数据版本一同读出，在更新时让版本号加一，在提交数据时取出数据库表对应的数据版本号与当前版本号对比，如果当前版本号大于数据库表数据版本号，则更新成功，否则认为是过期数据

4. 死锁概念

死锁是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外	力作用,它们都将无法推进下去.此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等	的进程称为死锁进程.
死锁产生原因及解决方法

*死锁的第一种情况*
一个用户A 访问表A(锁住了表A),然后又访问表B；另一个用户B 访问表B(锁住了表B)，然后企图访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。

*解决方法：*
这种死锁比较常见，是由于程序的BUG产生的，除了调整的程序的逻辑没有其它的办法。仔细分析程序的逻辑，	对于数据库的多表操作时，尽量按照相同的顺序进 行处理，尽量避免同时锁定两个资源，如操作A和B两张表	时，总是按先A后B的顺序处理， 必须同时锁定两个资源时，要保证在任何时刻都应该按照相同的顺序来锁定	资源。

*死锁的第二种情况*
用户A查询一条纪录，然后修改该条纪录；这时用户B修改该条纪录，这时用户A的事务里锁的性质由查询的共享锁企图上升到独占锁，而用户B里的独占锁由于A 有共享锁存在所以必须等A释放掉共享锁，而A由于B的独占锁而无法上升的独占锁也就不可能释放共享锁，于是出现了死锁。这种死锁比较隐蔽，但在稍大点的项 目中经常发生。如在某项目中，页面上的按钮点击后，没有使按钮立刻失效，使得用户会多次快速点击同一按钮，这样同一段代码对数据库同一条记录进行多次操 作，很容易就出现这种死锁的情况。

*解决方法：*
1、对于按钮等控件，点击后使其立刻失效，不让用户重复点击，避免对同时对同一条记录操作。
2、使用乐观锁进行控制。给表中多创一个字段，用来放版本号，当每次要跟新数据时，让版本号加一，然后判断
库里的版本号是否小于当前的版本号，是则跟新，否则认为是过期数据，乐观锁机制避免了长事务中的数据 库加锁开销（用户A和用户B操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系统整体性能表现。
3、使用悲观锁进行控制。悲观锁大多数情况下依靠数据库的锁机制实现，如Oracle的Select … for update语句，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。如一个金融系统， 当某个操作员读取用户的数据，并在读出的用户数据的基础上进行修改时（如更改用户账户余额），如果采用悲观锁机制，也就意味着整个操作过程中（从操作员读 出数据、开始修改直至提交修改结果的全过程，甚至还包括操作员中途去煮咖啡的时间），数据库记录始终处于加锁状态，可以想见，如果面对成百上千个并发，这 样的情况将导致灾难性的后果。所以，采用悲观锁进行控制时一定要考虑清楚。

*死锁的第三种情况*
如果在事务中执行了一条不满足条件的update语句，则执行全表扫描，把行级锁上升为表级锁，多个这样的事务执行后，就很容易产生死锁和阻塞。类似的情 况还有当表中的数据量非常庞大而索引建的过少或不合适的时候，使得经常发生全表扫描，最终应用系统会越来越慢，最终发生阻塞或死锁。

*解决方法:*
SQL语句中不要使用太复杂的关联多表的查询；使用“执行计划”对SQL语句进行分析，对于有全表扫描的SQL	语句，建立相应的索引进行优化。