#jwt的实现原理

![](../img/jwt.png)

JWT 特点： 
体积小，因而传输速度快
传输方式多样，可以通过URL/POST参数/HTTP头部等方式传输
严格的结构化。它自身（在 payload 中）就包含了所有与用户相关的验证消息，如用户可访问路由、访问有效期等信息，服务器无需再去连接数据库验证信息的有效性，并且 payload 支持为你的应用而定制化。
支持跨域验证，可以应用于单点登录。

JWT是Auth0提出的通过对JSON进行加密签名来实现授权验证的方案，编码之后的JWT看起来是这样的一串字符：
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ

由 . 分为三段，通过解码可以得到：

1、头部（Header）

// 包括类别（typ）、加密算法（alg）；

{
  "alg": "HS256",

  "typ": "JWT"
}

jwt的头部包含两部分信息：

声明类型，这里是jwt

声明加密的算法 通常直接使用 HMAC SHA256

2、载荷（payload）

载荷（payload） 载荷就是存放有效信息的地方。

3、签名（signature)

签名的目的：签名实际上是对头部以及载荷内容进行签名。所以，如果有人对头部以及载荷的内容解码之后进行修改，再进行编码的话，那么新的头部和载荷的签名和之前的签名就将是不一样的。而且，如果不知道服务器加密的时候用的密钥的话，得出来的签名也一定会是不一样的。 这样就能保证token不会被篡改。
最后，我们将上面拼接完的字符串用HS256算法进行加密。在加密的时候，我们还需要提供一个密钥（secret）。类似盐
这里在第三步我们得到 JWT 之后，需要将JWT存放在 client，之后的每次需要认证的请求都要把JWT发送过来。（请求时可以放到 header 的 Authorization ）

一、使用JSON Web Token的好处？

1.性能问题。 JWT方式将用户状态分散到了客户端中，相比于session，可以明显减轻服务端的内存压力。 Session方式存储用户id的最大弊病在于Session是存储在服务器端的，所以需要占用大量服务器内存， 对于较大型应用而言可能还要保存许多的状态，一般还需借助nosql和缓存机制来实现session的存储，如果是分布式应用还需session共享。 

2.单点登录。 JWT能轻松的实现单点登录，因为用户的状态已经被传送到了客户端。 token 可保存自定义信息，如用户基本信息，web服务器用key去解析token，就获取到请求用户的信息了。 我们也可以配置它以便包含用户拥有的任何权限。这意味着每个服务不需要与授权服务交互才能授权用户。 

3.前后端分离。 以前的传统模式下，后台对应的客户端就是浏览器，就可以使用session+cookies的方式实现登录， 但是在前后分离的情况下，后端只负责通过暴露的RestApi提供数据，而页面的渲染、路由都由前端完成。因为rest是无状态的，因此也就不会有session记录到服务器端。 

4.兼容性。 支持移动设备，支持跨程序调用，Cookie 是不允许垮域访问的，而 Token 则不存在这个问题。 

5.可拓展性。 jwt是无状态的，特别适用于分布式站点的单点登录（SSO）场景。 比如有3台机器（A、B、C）组成服务器集群，若session存在机器A上，session只能保存在其中一台服务器，此时你便不能访问机器B、C，因为B、C上没有存放该Session， 而使用token就能够验证用户请求合法性，并且我再加几台机器也没事，所以可拓展性好。 

6.安全性。因为有签名，所以JWT可以防止被篡改。

JWT是基于token的身份认证的方案。

json web token全称。可以保证安全传输的前提下传送一些基本的信息，以减轻对外部存储的依赖，减少了分布式组件的依赖，减少了硬件的资源。
可实现无状态、分布式的Web应用授权，jwt的安全特性保证了token的不可伪造和不可篡改。
本质上是一个独立的身份验证令牌，可以包含用户标识、用户角色和权限等信息，以及您可以存储任何其他信息（自包含）。任何人都可以轻松读取和解析，并使用密钥来验证真实性。

缺陷：

1）JWT在生成token的时候支持失效时间，但是支持的失效时间是固定的，比如说一天。 但是用户在等出的时候是随机触发的，那么我们jwt token来做这个失效是不可行的，因为jwt在初始化的时候已经定死在什么时候过期了。 采用其他方案，在redis中存储token，设置token的过期时间，每次鉴权的时候都会去延长时间

 2）jwt不适合存放大量信息，信息越多token越长

三、校验简介

整个jwt的结构是由header.playload.sign连接组成，只有sign是用密钥加密的，而所有的信息都在header和playload中可以直接获取，sign的作用只是校验header和playload的信息是否被篡改过，所以jwt不能保护数据，但以上的特性可以很好的应用在权限认证上。

1.加密

比如要加密验证的是userid字段，首先按前面的格式组装json消息头header和消息体playload，按header.playload组成字符串，再根据密钥和HS256加密header.playload得到sign签名，最后得到jwtToken为header.playload.sign，在http请求中的url带上参数想后端服务请求认证。

2.解密

后端服务校验jwtToken是否有权访问接口服务，进行解密认证，如校验访问者的userid，首先
用将字符串按.号切分三段字符串，分别得到header和playload和sign。然后将header.playload拼装用密钥和HAMC SHA-256算法进行加密然后得到新的字符串和sign进行比对，如果一样就代表数据没有被篡改，然后从头部取出exp对存活期进行判断，如果超过了存活期就返回空字符串，如果在存活期内返回userid的值。

四、在django中是怎样实现的

1、配置

在设置文件REST_FRAMEWORK项中添加jwt认证
添加JWT认证选项

2、后端接口、视图设置

Django REST framework JWT内已经提供了登录签发JWT的视图方法，可以直接使用，不用再定义视图逻辑。

1)在urls中定义路由规则

	obtain_jwt_token即内置的登录jwt视图，直接使用无需再定义。

2)重写jwt_response_payload_handler方法

直接使用Django REST framework JWT提供的视图方法时，其默认的返回值只有token值，若需要前端接收到用户其他信息，需要重写其内部的jwt_response_payload_handler方法。
源码中jwt_response_payload_handler接收了token、user、requests参数，但返回只返回了token值。

3)自定义jwt_response_payload_handler后需在配置文件中声明使用修改后的方法

4)使用JWT认证登录的后端设置就完成了。