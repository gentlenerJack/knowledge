
# Python的内存管理机制

## 一.引入计数

每个对象都有指向该对象的引用总数,对象，每个对象都包含一个头部信息，包含：类型标识符和引用计数器。  
`sys.getrefcount(n)  # 查看引入计数.`

#### 引入计数增加   
1,对象被创建, 如n=77  
2,另外的别人被创建, 如m=n   
3,在容器里,如a_list=[77,99]  
4,作为参数传入函数,比如sys.getrefcount(n)


`容器对象：如列表，元组，字典，集合，队列，collections，包含的不是元素对象本身，而是指向各个元素的引用`

#### 引入计数减少

1,对象名被显式销毁,如del n  
2,对象的一个别名被赋值给其他对象, 如n=77,n=66  
3,被从容器对象中移除,a_list.remove(77)  
4,对象离开它的作用域, 如对象作为参数传入函数,函数执行完成

#### 优势和缺点

###### 优势

1,简单,直观  
2,实时性,没有引用,就释放资源,不用像其他机制一样等待特定时机,处理回收内存的时间分摊到了平时

###### 劣势

1,维护引用计数需要消耗资源  
2,循环引用问题:对象相互引用,占用的内存无法被回收,使系统内存的浪费,内存泄漏(python使用 标志-清除机制 解决这一问题)  

```python
c=[22,33]
d=[55,66] #循环引用`
c.append(d)#c的引用+1=2 
d.append(c)#d的引用+1=2
```


## 二.垃圾回收GC(Grabage Collection)

python中的对象增多,占用的内存随之增多,启用垃圾回收,将没有的对象清除,某个对象的引入计数降为0时,说明没有任何引用指向该对象,则该对象可被垃圾回收,python进行垃圾回收时,不能进行其他任务,因此频繁垃圾回收降低python效率.

###### 触发条件:

1.手动调用gc.collect()  
2.对象分配次数和取消分配对象的次数的差大于阈值时就会触发垃圾回收  
3.程序功能退出的时候
     
### 标记-清除
1.	GC给所有对象加上标记，将标记完的对象视作一个点，对象间的引用关系视作边，最终点和边构成有向图  
2.	从根对象（全局变量，栈，寄存器）出发，沿有向边遍历整个图，达不到的对象就是需要清理的对象。

`寄存器：寄存器是CPU内部很小的存储单元，一个寄存器只有几个字节`

### 分代回收

python将对象分为 0代, 1代, 2代,刚创建的对象为0代，对象分配次数和取消分配对象的次数的差大于阈值时就会触发垃圾回收，他们对应的阈值分别为700,10,10。  
```python
import gc 
print(gc.get_threshold())

[700,10,10] # 输出结果
```
经过 "标记-清除" 存活的对象,对象的代数+1,归入下一代对象。10次0代回收出发1次一代回收，10次1代回收出发1次2代回收，经过多代回收存活下来的对象，则不会是涉及循环引用的对象  
```python
gc.set_threshold([600,15,15]) # 更改阈值 
```

### 内存池机制（Pymalloc机制）

1,针对大小小于256kb的小对象，pymalloc会在内存池中申请内存空间，当对象被销毁，python只会将这个对象引用回收掉；不会调用free函数释放内存，将该内存块留在内存池中以便下次使用  
2,当大于256kb，则会直接执行 new/malloc 的行为来申请新的内存空间。  
`python中缓存了整数（-5到256）和短字符串每个对象在内存中只存有一份，引用所指对象就是相同的赋值语句只是创造了新的引用，而不是对象本身（ is 判断变量指针指向的对象是否相同）`

```
内存池（memory pool）:
一种内存分配方式。预先在内存中申请一定数量的，大小相等的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了之后再申请新的内存。
优势：和直接使用new、malloc等API申请分配内存相比，在由于所申请内存块的大小不定时，产生的内存碎片更少，效率更高
```

###### 金字塔

1,第0层是C中的malloc，free等内存分配和释放函数进行操作;  
2,第1层和第2层是内存池，有Python的接口函数PyMem_Malloc函数实现，当对象小于256K时有该层直接分配内存；  
3,第3层是最上层，也就是我们对Python对象的直接操作；

