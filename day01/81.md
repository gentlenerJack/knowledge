#什么是断言？应用场景？

Python的assert是用来检查一个条件，如果它为真，就不做任何事。如果它为假，则会抛出AssertError并且包含错误信息。例如：

x = 23
assert x > 0, "x is not zero or negative"
assert x%2 == 0, "x is not an even number"

结果显示：
	assert x%2 == 0 "x is not an even number"
	AsserttionError:x is not an even number

很多人用assert作为一个很快和容易的方法来在参数错误的时候抛出异常。但这样做是错的，非常错误，有两个原因。首先AssertError不是在测试参数时应该抛出的错误。你不应该像这样写代码：
	x = "14"
if not isinstance(x, int):
    raise AssertionError("not an int")

结果显示：
	raise AssertionError("not an int")
	引发AssertionError（‘not an int’）
AssertionError :not an int
你应该抛出TypeError的错误，assert会抛出错误的异常。

使用assert没有特定的规则，用于：
	1.防御性的编程
	2.运行时检查程序逻辑
	3.检查约定
	4.程序常量
	5.检查文档
assert可以用于测试代码，是一种很方便的单元测试方法，接受这些测试再用-O标志运行时不会做任何事

关于断言的意见有很多，因为它能确保代码的正确性。如果你确定代码是正确的，那么就没有用断言的必要了，因为他们从来不会运行失败，你可以直接移除这些断言。如果你确定检查会失败，那么如果你不用断言，代码就会通过编译并忽略你的检查。

在以上两种情况下会很有意思，当你比较肯定代码但是不是绝对肯定时。可能你会错过一些非常古怪的情况。在这个情况下，额外的运行时检查能帮你确保任何错误都会尽早地被捕捉到

另一个好的使用断言的方式是检查程序的不变量。一个不变量是一些你需要依赖它为真的情况，除非一个bug导致它为假。如果有bug，最好能够尽早发现，所以我们为它进行一个测试，但是又不想减慢代码运行速度。所以就用断言，因为它能在开发时打开，在产品阶段关闭。

一个非变量的例子可能是，如果你的函数希望在它开始时有数据库的连接，并且承诺在它返回的时候仍然保持连接，这就是函数的不变量：

def some_function(arg):
    assert not DB.closed()
    ... # code goes here
    assert not DB.closed()
    return result

断言本身就是很好的注释，胜过你直接写注释

when we reach here , we know that n >2

你可以通过添加断言来确保它：

assert n > 2

断言也是一种防御型编程。你不是让你的代码防御现在的错误，而是防止在代码修改后引发的错误。理想情况下，单元测试可以完成这样的工作，可是需要面对的现实是，它们通常是没有完成的。人们可能在提交代码前会忘了运行测试代码。有一个内部检查是另一个阻挡错误的防线，尤其是那些不明显的错误，却导致了代码出问题并且返回错误的结果。









下面是建议的不要用断言的场景：

　　☆不要用它测试用户提供的数据
　　☆不要用断言来检查你觉得在你的程序的常规使用时会出错的地方。断言是用来检查非常罕见的问题。你的用户不应该看到任何断言错误，如果他们看到了，这是一个bug，修复它。
　　☆有的情况下，不用断言是因为它比精确的检查要短，它不应该是懒码农的偷懒方式。
　　☆不要用它来检查对公共库的输入参数，因为它不能控制调用者，所以不能保证调用者会不会打破双方的约定。
　　☆不要为你觉得可以恢复的错误用断言。换句话说，不用改在产品代码里捕捉到断言错误。
　　☆不要用太多断言以至于让代码很晦涩。

















