#简述进程、线程、协程的区别以及应用场景?
```
进程：

什么是进程：进程是资源分配的最小单位一个可执行的的程序被系统加载在内存中 一个进程具有:就绪，运行，中断，僵死，结束等状态(不同操作系统不一样)。 进程支持并发和并行
进程属性：进程与进程之间不能相互访问；都有自己独立的内存；不共享任何状态；调度由操作系统完成

进程间通信：

进程之间数据不共享 ，所以需要进程通信
通信的三种方式：进程队列queue；管道pipe；共享数据manage

进程说明：

多个进程可以在不同的 CPU 上运行，互不干扰

同一个CPU上，可以运行多个进程，由操作系统来自动分配时间片

进程池：

开多进程是为了并发，通常有几个cpu核心就开几个进程，但是进程开多了会影响效率，主要体现在切换的开销，所以引入进程池限制进程的数量。
这时候就用到了进程池，进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进进程，那么程序就会等待，直到进程池中有可用进程为止。

进程和程序的区别：

进程是系统进行资源分配和调度的一个独立单位 
一个程序对应多个进程，一个进程为多个程序服务（两者之间是多对多的关系） 
一个程序执行在不同的数据集上就成为不同的进程，可以用进程控制块来唯一地标识每个进程

线程：

什么是线程：

线程是操作系统能够进行运算调度的最小单位 
线程是包含在进程中的
进程自己是无法执行的，是靠线程进行执行的

特点：

一个进程中可以有多个线程，每个线程并行执行不同的任务
线程的资源可以共享
线程可以操作同一进程中的其他线程

join()方法：
实现所有线程都执行结束后再执行主线程 . 如果一个线程或者在函数执行的过程中调用另一个线程，并且希望待其完成操作后才能执行，那么在 调用线程的时就可以使用被调线程的join方法join([timeout]) timeout：可选参数，线程运行的最长时间
isAlive()方法：
查看线程是否还在运行
getName()方法：
获得线程名
setDaemon()方法：
主线程退出时，需要子线程随主线程退出，则设置子线程的setDaemon()
线程池：
系统启动一个新线程的成本是比较高的，因为它涉及与操作系统的交互。在这种情形下，使用线程池可以很好地提升性能，尤其是当程序中需要创建大量生存期很短暂的线程时，更应该考虑使用线程池。
线程池在系统启动时即创建大量空闲的线程，程序只要将一个函数提交给线程池，线程池就会启动一个空闲的线程来执行它。当该函数执行结束后，该线程并不会死亡，而是再次返回到线程池中变成空闲状态，等待执行下一个函数。
信号量：
信号量是指对共同资源进行访问控制的对象。在访问资源之前，线程必须从信号量获取	许可。在访问完资源之后，这个线程必须将许可返回个给信号量 
线程锁：
线程锁也叫用户锁 也叫互斥锁
当前一个线程还未操作完成前其他所有线程都无法对其操作，即使已经释放了GIL锁
线程锁的优点：
确保了某一段代码只能有一个线程从头到尾完整的执行
线程锁的缺点：
首先是阻止了多线程的多发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大的降低。
其次由于可以存在多个锁，不同线程存在不同的锁，并试图获取对方持有的锁时，可以会造成锁死，导致多个线程全部挂起，既不能执行也不能结束，只能靠操作系统强制终止。
协程：
什么是协程：
协程是微线程 
协程拥有自己的寄存器上下文和栈
协程能保留上一次调用时的状态 
为什么能处理并发：
遇IO组自动切换
内部封装的有Greenlet模块(遇到IO手动切换) 和 Gevent模块(遇到IO自动切换)
Greenlet：
遇IO操作 手动切换 
Gevent：
Gevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程
其实Gevent模块仅仅是对greenlet的再封装，将I/O间的手动切换变成自动切换
Gevent原理是只要遇到I/O操作就会自动切换到下一个协程
进程、线程、协程区别：
先有进程，然后进程可以创建线程，线程是依附在进程里面的， 线程里面可以包含多个协程
进程之间不共享全局变量，线程之间共享全局变量，但是要注意资源竞争的问题
多进程开发比单进程多线程开发稳定性要强，但是多进程开发比多线程开发资源开销要大
多线程开发线程之间执行是无序的，协程之间执行按照一定顺序交替执行
协程以后主要用在网络爬虫和网络请求，开辟一个协程大概需要5k空间，开辟一个线程需要512k空间， 开辟一个进程占用资源最多
栈：
栈的定义：
栈是一中数据集合【就是只能一端进行插入或者删除的列表(后进先出)】
栈的特点：
后进先出
栈的基本操作：
Stack() 创建一个空的新栈。 它不需要参数，并返回一个空栈
push(item)将一个新项添加到栈的顶部。它需要 item 做参数并不返回任何内容
pop() 从栈中删除顶部项。它不需要参数并返回 item 。栈被修改
peek() 从栈返回顶部项，但不会删除它。不需要参数。 不修改栈
isEmpty() 测试栈是否为空。不需要参数，并返回布尔值
size() 返回栈中的 item 数量。不需要参数，并返回一个整数。
栈的作用：
匹配括号是否成对出现
队列：
队列的定义：
队列是一个数据集合，仅允许在列表的一端进行插入，另外一端进行删除
插入的一端称为队尾（rear），插入动作叫进队或入队 　　　　　　
进行删除的一端称为对头（front），删除动作称为出队 
队列性质：先进先出（First-in, First-out）
双向队列：队列的两端都允许进行进队和出队操作 
队列的使用：
导入： from collectios import deque
创建队列：queue = deque(li) 
进队： append
出队： popleft
双向队列队首进队：appendleft
双向队列队尾出队：pop 










27.	什么是GIL锁?
GIL定义：
GIL，the Global Interpreter Lock，直译为“全局解释锁”
GIL存在原因
CPython在执行多线程的时候并不是线程安全的，所以为了程序的稳定性，加一把全局解释锁，能够确保任何时候都只有一个Python线程执行。
我们所说的Python全局解释锁（GIL）简单来说就是一个互斥体（或者说锁），这样的机制只允许一个线程来控制Python解释器。
      	这就意味着在任何一个时间点只有一个线程处于执行状态。GIL对执行单线程任务的程序员们来说并没什么显著影响，但是它成为了计算密集型（CPU-bound）和多线程任务的性能瓶颈。
GIL即使在拥有多个CPU核的多线程框架下都只允许一次运行一个线程
GIL的弊端
GIL对计算密集型的程序会产生影响。因为计算密集型的程序，需要占用系统资源。GIL的存在，相当于始终在进行单线程运算，这样自然就慢了。
IO密集型影响不大的原因在于，IO，input/output，这两个词就表明程序的瓶颈在于输入所耗费的时间，线程大部分时间在等待，所以它们是多个一起等（多线程）还是单个等（单线程）无所谓的。
GIL解决了Python中的什么问题？
Python利用引用计数来进行内存管理，这就意味着在Python中创建的对象都有一个引用计数变量来追踪指向该对象的引用数量。当数量为0时，该对象占用的内存即被释放。
GIL是解释器本身的一个单一锁，它增加的一条规则表明任何Python字节码的执行都需要获取解释锁。这有效地防止了死锁（因为只存在一个锁）并且不会带来太多的性能开销。但是这的确使每一个计算密集型任务变成了单线程。
      GIL虽然也被其他语言解释器使用（如Ruby），但是这不是解决这个问题的唯一办法。一些编程语言通过使用除引用计数以外的方法（如垃圾收集）来避免GIL对线程安全内存管理的请求。
      从另一方面来看，这也意味着这些语言通常需要添加其他性能提升功能（如JIT编译器）来弥补GIL单线程性能优势的损失。

28.Python 中如何使用线程池和进程池?
进程池的概念：
进程池是资源进程、管理进程组成的技术的应用。
python中，进程池内部会维护一个进程序列。当需要时，程序会去进程池中获取一个进程。如果进程池序列中没有可供使用的进程，那么程序就会等待，直到进程池中有可用进程为止。
multiprocessing.Pool常用函数解析：
apply_async(func[, args[, kwds]]) ：使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表；
·	close()：关闭Pool，使其不再接受新的任务；
·	terminate()：不管任务是否完成，立即终止；
·	join()：主进程阻塞，等待子进程的退出， 必须在close或terminate之后使用；
进程池技术的应用至少由以下两部分组成：
资源进程
预先创建好的空闲进程，管理进程会把工作分发到空闲进程来处理。
管理进程
管理进程负责创建资源进程，把工作交给空闲资源进程处理，回收已经处理完工作的资源进程。
上面资源进程跟管理进程的概念很好理解，下面就是进程池的关键，管理进程如何有效的管理资源进程，分配任务给资源进程，回收空闲资源进程，管理进程要有效的管理资源进程，那么管理进程跟资源进程间必然需要交互，通过IPC，信号，信号量，消息队列，管道等进行交互。
什么是线程池：
一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。 
线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。
任务调度以执行线程的常见方法是使用同步队列，称作任务队列。池中的线程等待队列中的任务，并把执行完的任务放入完成队列中。
线程池模式一般分为两种：HS/HA半同步/半异步模式、L/F领导者与跟随者模式。
·	
半同步/半异步模式又称为生产者消费者模式，是比较常见的实现方式，比较简单。分为同步层、队列层、异步层三层。同步层的主线程处理工作任务并存入工作队列，工作线程从工作队列取出任务进行处理，如果工作队列为空，则取不到任务的工作线程进入挂起状态。由于线程间有数据通信，因此不适于大数据量交换的场合。

领导者跟随者模式，在线程池中的线程可处在3种状态之一：领导者leader、追随者follower或工作者processor。任何时刻线程池只有一个领导者线程。事件到达时，领导者线程负责消息分离，并从处于追随者线程中选出一个来当继任领导者，然后将自身设置为工作者状态去处置该事件。处理完毕后工作者线程将自身的状态置为追随者。这一模式实现复杂，但避免了线程间交换任务数据，提高了CPU cache相似性。在ACE(Adaptive Communication Environment)中，提供了领导者跟随者模式实现。
·	
线程池的伸缩性对性能有较大的影响。
创建太多线程，将会浪费一定的资源，有些线程未被充分使用。
销毁太多线程，将导致之后浪费时间再次创建它们。
创建线程太慢，将会导致长时间的等待，性能变差。
销毁线程太慢，导致其它线程资源饥饿
应用范围：
1、需要大量的线程来完成任务，且完成任务的时间比较短。 WEB服务器完成网页请求这样的任务，使用线程池技术是非常合适的。因为单个任务小，而任务数量巨大，你可以想象一个热门网站的点击次数。 但对于长时间的任务，比如一个Telnet连接请求，线程池的优点就不明显了。因为Telnet会话时间比线程的创建时间大多了。
2、对性能要求苛刻的应用，比如要求服务器迅速响应客户请求。
3、接受突发性的大量请求，但不至于使服务器因此产生大量线程的应用。突发性大量客户请求，在没有线程池情况下，将产生大量线程，虽然理论上大部分操作系统线程数目最大值不是问题，短时间内产生大量线程可能使内存到达极限，并出现"OutOfMemory"的错误。

```