python中的内存泄漏
什么是内存泄漏:
由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。
成因
1.	Python 本身的垃圾回收机制无法回收 重写了del方法的循环引用对象
2.	python垃圾回收机制被禁用或者设置成debug状态, 垃圾所占的内存不会被自动释放
如何避免
	管理好每个python对象的引用，尽量在不需要使用对象的时候，断开所有引用,del object 来删除一个对象的引用计数
	尽量少通过循环引用组织数据，可以改用weakref做弱引用或者用id之类的句柄访问对象
弱引用:与强引用相对，它是不会被垃圾收集器销毁的，但是如果一个对象只剩下一个弱引用，那么它可能被垃圾收集器收回通过调用weakref模块的ref(obj[,callback])来创建一个弱引用,callback是一个可选的函数，这个函数在弱引用被销毁时调用。回调函数callback要求单个参数（弱引用的对象）。
	通过gc模块的接口可以检查出每次垃圾回收有哪些对象不能自动处理，再逐个逐个处理
检测
3.	可以通过 sys.getrefcount(obj) 来获取对象的引用计数，并根据返回值是否为 0 来判断是否内存泄漏。如果返回的引用计数不为 0，说明在此刻对象 obj 是不能被垃圾回收器回收掉的。
4.	在gc模块的基础上，结合pyrasite工具，对当前正在运行的程序进行内存泄漏方面的调试。
pyrasite 是用于将任意代码注入运行的 Python 进程的工具
gc.isenabled() #如果当前自动收集器已经打开，返回True.  gc.disable() #关闭自动收集器。此时若产生了不可访问的垃圾对象将不会被释放，会持续占用内存。 gc.collect() #收集垃圾对象，并返回收集器不可访问的垃圾对象个数，同时释放所有收集到的对象并将无法释放的垃圾对象保存至gc.garbage列表中。 gc.set_debug() # 设置当前收集器的调试状态，可通过该函数打印经过收集器的所有对象信息，不可访问的对象信息等等，还可以将不可访问的对象保存至gc.garbage列表中(即不释放该对象)，以便开发人员定位。 gc.garbage # 存放无法释放的对象详细信息，是一个列表，可通过len(gc.garbage)查看造成内存泄漏的对象个数。

(1)．获取进程id并使用pyrasite模块在该进程进行gc调试

(2)．获取当前gc状态，等待进程运行相关功能模块

(3).手动进行垃圾对象收集，分析收集结果。

